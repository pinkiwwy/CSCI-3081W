/* STUDENTS:  DO NOT EDIT THIS FILE.  INSTEAD, MODIFY YOUR OWN PROJECT
 * CODE TO FIT THE SPECIFICATION GIVEN BY THE TESTS IN THIS FILE.
 *
 * If you DO modify it, we overwrite it with a fresh version from our repo
 * when grading, so you can't use it to fudge the tests anyway.
 *
 * This file is used by the CS3081W auto-grading system.
 *
 * Please note, the assessment tests for grading, will use the same include
 * files, class names, and function names for accessing students' code that you
 * find in this file.  So students, if you write your code so that it passes
 * these feedback tests, you can be assured that the auto-grader will at least
 * be able to properly link with your code.
 */

/*******************************************************************************
 * Includes
 ******************************************************************************/
#include <gtest/gtest.h>
#include "../src/robot.h"

/*******************************************************************************
 * Test Cases
 ******************************************************************************/
#ifdef ROBOT_TEST

TEST(Robot, Sanity) {
  csci3081::robot_params params;
  params.pos = Position(0, 0);
  params.angle_delta = 15;
  params.battery_max_charge = 100.;
  params.collision_delta = 0.1;
  params.radius = 5.0;
  csci3081::Robot r1 = csci3081::Robot(&params);

  EXPECT_EQ(r1.get_name(), "Robot0");
  EXPECT_DOUBLE_EQ(r1.radius(), 5.0) << "FAIL: Bad radius";
  EXPECT_DOUBLE_EQ(r1.collision_delta(), 0.1) << "FAIL: Bad collision delta";
  EXPECT_DOUBLE_EQ(r1.battery_level(), 100.0) << "FAIL: Bad battery level";
  r1.speed(10.0);
  EXPECT_EQ(r1.speed(), 5.0) << "FAIL: Max speed exceeded";
}

TEST(Robot, Reset) {
  csci3081::robot_params params;
  params.pos = Position(5.0, 5.0);
  params.angle_delta = 15;
  params.battery_max_charge = 100.;
  params.collision_delta = 0.1;
  params.radius = 5.0;
  csci3081::Robot r1 = csci3081::Robot(&params);

  r1.speed(3.0);
  r1.TimestepUpdate(5);

  r1.Reset();
  EXPECT_DOUBLE_EQ(r1.speed(), 0) << "FAIL: Reset speed";
  EXPECT_DOUBLE_EQ(r1.battery_level(), 100.0) << "FAIL: Reset battery";
}

TEST(Robot, BatteryDepletion) {
  csci3081::robot_params params;
  params.pos = Position(0, 0);
  params.angle_delta = 15;
  params.battery_max_charge = 100.;
  params.collision_delta = 0.1;
  params.radius = 5.;
  csci3081::Robot r1 = csci3081::Robot(&params);

  double level = r1.battery_level()
  r1.TimestepUpdate(100);

  // Test that the battery has some depletion after moving.
  EXPECT_LT(std::fabs(r1.battery_level(), level) <<
      "FAIL: Battery not depleted with move";
}

TEST(Robot, AcceptRecharge) {
  csci3081::robot_params params;
  params.pos = Position(0, 0);
  params.angle_delta = 15;
  params.battery_max_charge = 100.;
  params.collision_delta = 0.1;
  params.radius = 5.;
  csci3081::Robot r1 = csci3081::Robot(&params);

  double level = r1.battery_level()
  r1.TimestepUpdate(100);
  r1.Accept(EventRecharge());

  // Test that the battery has some depletion after moving.
  EXPECT_DOUBLE_EQ(r1.battery_level(), params.battery_max_charge) <<
      "FAIL: Event recharge did not recharge robot battery";
}

TEST(Robot, AcceptCollision) {
  csci3081::robot_params params;
  params.pos = Position(0, 0);
  params.angle_delta = 15;
  params.battery_max_charge = 100.;
  params.collision_delta = 0.1;
  params.radius = 5.;
  csci3081::Robot r1 = csci3081::Robot(&params);

  r1.sensor_touch.activated(false);
  EventCollision ec;
  ec.collided(true);
  r1.Accept(ec);

  EXPECT_TRUE(r1.sensor_touch.activated()) <<
      "FAIL: Sensor not activated with collision";
}


#endif /* ROBOT_TEST */
